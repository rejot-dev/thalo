2026-01-07T10:18Z create reference "Clean Code by Robert C. Martin" ^clean-code #programming #books
  ref-type: "book"
  author: "Robert C. Martin"
  published: 2008-08-01
  status: "read"

  # Summary
  A handbook of agile software craftsmanship that emphasizes writing readable, maintainable code
  through meaningful names, small functions, and clear structure.

  # Key Takeaways
  - Functions should do one thing and do it well
  - Names should reveal intent
  - Comments are often a sign of failure to express yourself in code
  - Boy Scout Rule: Leave the code cleaner than you found it

2026-01-07T10:18Z create reference "The Pragmatic Programmer" ^pragmatic-programmer #programming #books
  ref-type: "book"
  author: "David Thomas & Andrew Hunt"
  published: 1999-10-20
  status: "read"

  # Summary
  A timeless guide to software development that covers everything from career development to coding
  best practices with practical, actionable advice.

  # Key Takeaways
  - DRY: Don't Repeat Yourself
  - Be a catalyst for change
  - Tracer bullets help you get on target faster
  - Orthogonality: Eliminate effects between unrelated things

2026-01-07T10:18Z create reference "Rich Hickey - Simple Made Easy" ^simple-made-easy #programming #talks
  ref-type: "video"
  author: "Rich Hickey"
  published: 2011-10-20
  url: "https://www.infoq.com/presentations/Simple-Made-Easy/"
  status: "read"

  # Summary
  Rich Hickey distinguishes between "simple" (not interleaved) and "easy" (near at hand), arguing
  that we often conflate them to our detriment.

  # Key Takeaways
  - Simple is objective, easy is relative to the observer
  - Complecting things together makes systems harder to change
  - We should choose simple constructs even when they're not easy
  - Reliability requires simplicity

  # Related
  - ^clean-code

2026-01-07T10:18Z create reference "You Don't Need That Abstraction" ^no-abstraction #programming #articles
  ref-type: "article"
  author: "Dan Abramov"
  url: "https://overreacted.io/goodbye-clean-code/"
  published: 2020-01-11
  status: "read"

  # Summary
  A reflection on the costs of premature abstraction, challenging conventional "clean code" wisdom
  by showing how abstractions can make code harder to change.

  # Key Takeaways
  - Clean code is not a goal, it's a tool
  - Obsessing over removing duplication can create coupling
  - Some duplication is okay if use cases might diverge
  - Team dynamics matter more than code aesthetics

2026-01-07T10:18Z create opinion "Premature abstraction is worse than duplication" ^opinion-premature-abstraction #programming #architecture
  confidence: "high"
  related: ^no-abstraction, ^pragmatic-programmer

  # Claim
  Abstracting too early creates rigid, hard-to-change code. It's better to tolerate some duplication
  until patterns clearly emerge.

  # Reasoning
  - Abstractions encode assumptions about what varies together
  - Early abstractions often encode the wrong assumptions
  - Changing a wrong abstraction is harder than merging duplicated code
  - The Rule of Three exists for a reason: wait for the third instance

  # Caveats
  - This doesn't excuse copy-paste programming
  - Some abstractions (like API boundaries) need to be designed upfront
  - Experience helps you recognize when abstraction is appropriate

2026-01-07T10:18Z create opinion "Comments explain why, not what" ^opinion-comments #programming #documentation
  confidence: "high"
  related: ^clean-code

  # Claim
  Comments should explain intent, constraints, and non-obvious decisionsâ€”not describe what the code
  does, which should be self-evident.

  # Reasoning
  - Code describes "what" better than comments ever could
  - Comments explaining "what" go stale as code changes
  - "Why" comments capture context that code cannot express
  - Business rules, workarounds, and trade-offs deserve comments

  # Caveats
  - Complex algorithms may need "what" explanations
  - Public API documentation is a different category
  - Regex and obscure syntax benefit from inline explanation

2026-01-07T10:18Z create reference "TypeScript 5.0 Release Notes" ^typescript-5 #typescript #releases
  ref-type: "article"
  author: "Microsoft"
  url: "https://devblogs.microsoft.com/typescript/announcing-typescript-5-0/"
  published: 2023-03-16
  status: "read"

  # Summary
  TypeScript 5.0 introduces decorators (Stage 3), const type parameters, and significant performance
  improvements with smaller package size.

  # Key Takeaways
  - Decorators finally standardized without experimental flag
  - `const` type parameters enable better literal inference
  - Multiple extends in tsconfig for config composition
  - 10-20% faster builds, 40% smaller package

2026-01-07T10:18Z create opinion "TypeScript const assertions beat enums" ^opinion-const-vs-enums #typescript
  confidence: "high"
  related: ^typescript-5

  # Claim
  `as const` objects should be preferred over TypeScript enums in most codebases due to better
  runtime characteristics and tooling support.

  # Reasoning
  - Enums emit runtime code, breaking type-stripping workflows
  - `as const` objects work with standard JavaScript semantics
  - Numeric enums have surprising auto-increment behavior
  - `as const` provides better tree-shaking

  # Caveats
  - Const enums can be useful for performance-critical paths
  - Existing codebases may have valid reasons to keep enums
  - String enums are less problematic than numeric ones

2026-01-07T10:18Z create journal "Reflecting on abstractions in software design" #programming #reflection ^asd
  subject: ^self
  type: "reflection"
  mood: "contemplative"
  context: "Reading discussions about clean code vs. pragmatic code"

  # Entry

  I've been thinking about how my views on abstraction have evolved. Early in my career, I was
  obsessed with eliminating duplication and creating "elegant" abstractions. Now I see that often
  those abstractions were premature.

  The best code I've written recently has been almost embarrassingly simple. Functions that do
  exactly one thing, with obvious names, minimal indirection. Code that a junior developer could
  understand in minutes.

  Maybe that's the real test: can someone else change this code confidently?

2026-01-07T10:18Z create lore "Simple code is often better than clever code" #programming #insights
  type: "insight"
  subject: ^self
  date: 2024 ~ 2026

  # Description
  Through years of maintaining production systems, I've learned that boring, obvious code outlasts
  clever abstractions. The code that's easiest to debug at 3 AM is code with minimal indirection and
  clear data flow.
