/**
 * Core action logic for the Thalo Synthesis GitHub Action.
 */

import * as core from "@actions/core";
import * as exec from "@actions/exec";
import * as github from "@actions/github";
import {
  runActualize,
  type SynthesisOutputInfo,
  type ActualizeEntryInfo,
  type ChangeMarker,
} from "@rejot-dev/thalo";
import { createChangeTracker } from "@rejot-dev/thalo/change-tracker/node";
import { loadWorkspace } from "./workspace.js";

/**
 * Action input configuration.
 */
export interface ActionInputs {
  githubToken: string;
  command: string;
  syntheses: string[];
  workingDirectory: string;
  branchName: string;
  prTitle: string;
  commitMessage: string;
  baseBranch: string;
}

/**
 * JSON structure passed to the user's command via stdin.
 */
export interface SynthesisCommandInput {
  file: string;
  title: string;
  linkId: string;
  sources: string[];
  prompt: string | null;
  entries: Array<{
    file: string;
    timestamp: string;
    entity: string;
    title: string;
    linkId: string | null;
    tags: string[];
    rawText: string;
  }>;
  currentCheckpoint: string;
  lastCheckpoint: string | null;
}

/**
 * Format a ChangeMarker to a string for JSON output.
 */
function formatCheckpoint(marker: ChangeMarker): string {
  return `${marker.type}:${marker.value}`;
}

/**
 * Format a SynthesisOutputInfo for passing to the user's command.
 */
function formatSynthesisForCommand(synthesis: SynthesisOutputInfo): SynthesisCommandInput {
  return {
    file: synthesis.file,
    title: synthesis.title,
    linkId: synthesis.linkId,
    sources: synthesis.sources,
    prompt: synthesis.prompt,
    entries: synthesis.entries.map((e: ActualizeEntryInfo) => ({
      file: e.file,
      timestamp: e.timestamp,
      entity: e.entity,
      title: e.title,
      linkId: e.linkId,
      tags: e.tags,
      rawText: e.rawText,
    })),
    currentCheckpoint: formatCheckpoint(synthesis.currentCheckpoint),
    lastCheckpoint: synthesis.lastCheckpoint ? formatCheckpoint(synthesis.lastCheckpoint) : null,
  };
}

/**
 * Generate the PR body content.
 */
function generatePRBody(syntheses: SynthesisOutputInfo[], hasFileChanges: boolean): string {
  if (hasFileChanges) {
    return `## Updated Syntheses

This PR was automatically generated by the Thalo Synthesis action.

### Syntheses Updated:
${syntheses.map((s) => `- **${s.title}** (\`^${s.linkId}\`) - ${s.entries.length} new entries`).join("\n")}

Please review the generated syntheses and merge when ready.`;
  } else {
    return `## Pending Syntheses

This PR was automatically generated by the Thalo Synthesis action.

The following syntheses have new entries and need to be updated:

${syntheses.map((s) => `- **${s.title}** (\`^${s.linkId}\`) - ${s.entries.length} new entries`).join("\n")}

Run your synthesis command to generate the updated content.`;
  }
}

/**
 * Create or update a PR with the synthesis changes.
 */
async function createOrUpdatePR(
  inputs: ActionInputs,
  syntheses: SynthesisOutputInfo[],
  hasFileChanges: boolean,
): Promise<void> {
  const octokit = github.getOctokit(inputs.githubToken);
  const { owner, repo } = github.context.repo;

  // Check if PR already exists
  const { data: prs } = await octokit.rest.pulls.list({
    owner,
    repo,
    head: `${owner}:${inputs.branchName}`,
    state: "open",
  });

  const body = generatePRBody(syntheses, hasFileChanges);

  if (prs.length > 0) {
    // Update existing PR
    await octokit.rest.pulls.update({
      owner,
      repo,
      pull_number: prs[0].number,
      body,
    });
    core.info(`Updated existing PR: ${prs[0].html_url}`);
    core.setOutput("pull-request-url", prs[0].html_url);
    core.setOutput("pull-request-number", prs[0].number);
  } else {
    // Create new PR
    const { data: pr } = await octokit.rest.pulls.create({
      owner,
      repo,
      title: inputs.prTitle,
      head: inputs.branchName,
      base: inputs.baseBranch,
      body,
    });
    core.info(`Created PR: ${pr.html_url}`);
    core.setOutput("pull-request-url", pr.html_url);
    core.setOutput("pull-request-number", pr.number);
  }
}

/**
 * Configure git for commits.
 */
async function configureGit(): Promise<void> {
  await exec.exec("git", ["config", "user.name", "github-actions[bot]"]);
  await exec.exec("git", ["config", "user.email", "github-actions[bot]@users.noreply.github.com"]);
}

/**
 * Run the synthesis action.
 *
 * 1. Load workspace and run actualize
 * 2. For each pending synthesis, run the user's command
 * 3. Commit changes and create/update PR
 */
export async function runSynthesisAction(inputs: ActionInputs): Promise<void> {
  const cwd = inputs.workingDirectory;

  // 1. Load workspace and run actualize
  core.info(`Loading workspace from: ${cwd}`);
  const workspace = await loadWorkspace(cwd);
  const tracker = await createChangeTracker({ cwd });

  const result = await runActualize(workspace, {
    targetLinkIds: inputs.syntheses.length > 0 ? inputs.syntheses : undefined,
    tracker,
  });

  core.info(`Tracker type: ${result.trackerType}`);

  // Warn about not found syntheses
  for (const id of result.notFoundLinkIds) {
    core.warning(`No synthesis found with link ID: ^${id}`);
  }

  // 2. Filter to syntheses that need updating
  const pending = result.syntheses.filter((s) => !s.isUpToDate);

  if (pending.length === 0) {
    core.info("All syntheses are up to date");
    core.setOutput("syntheses-updated", 0);
    return;
  }

  core.info(`Found ${pending.length} syntheses needing updates`);

  // Configure git
  await configureGit();

  // 3. Create branch (force delete if exists, then create fresh)
  try {
    await exec.exec("git", ["branch", "-D", inputs.branchName], { ignoreReturnCode: true });
  } catch {
    // Branch might not exist, that's fine
  }
  await exec.exec("git", ["checkout", "-b", inputs.branchName]);

  // 4. For each synthesis, run the user's command
  for (const synthesis of pending) {
    core.info(`Processing: ${synthesis.title} (^${synthesis.linkId})`);

    // Pass synthesis JSON to user command via stdin
    const synthesisJson = JSON.stringify(formatSynthesisForCommand(synthesis), null, 2);

    core.debug(`Synthesis input:\n${synthesisJson}`);

    try {
      await exec.exec(inputs.command, [], {
        input: Buffer.from(synthesisJson),
        cwd,
      });
    } catch (err) {
      const message = err instanceof Error ? err.message : String(err);
      core.error(`Failed to process synthesis ${synthesis.linkId}: ${message}`);
      throw err;
    }
  }

  // 5. Check if there are any changes from the command
  const statusOutput = await exec.getExecOutput("git", ["status", "--porcelain"]);
  const hasFileChanges = !!statusOutput.stdout.trim();

  if (!hasFileChanges) {
    // No file changes from command, but we still have pending syntheses
    // Create a marker file so we can create a PR
    core.info("No file changes from command, creating pending marker file");
    const pendingInfo = {
      generatedAt: new Date().toISOString(),
      pendingSyntheses: pending.map((s) => ({
        file: s.file,
        title: s.title,
        linkId: s.linkId,
        entriesCount: s.entries.length,
        currentCheckpoint: formatCheckpoint(s.currentCheckpoint),
      })),
    };
    const fs = await import("node:fs/promises");
    await fs.writeFile(`${cwd}/.thalo-pending.json`, JSON.stringify(pendingInfo, null, 2) + "\n");
  }

  core.debug(`Git status:\n${statusOutput.stdout}`);

  // 6. Commit and push
  await exec.exec("git", ["add", "."]);
  await exec.exec("git", ["commit", "-m", inputs.commitMessage]);
  await exec.exec("git", ["push", "-u", "origin", inputs.branchName, "--force"]);

  // 7. Create or update PR
  await createOrUpdatePR(inputs, pending, hasFileChanges);

  core.setOutput("syntheses-updated", pending.length);
}
